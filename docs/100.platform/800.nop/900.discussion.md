---
title: 群内讨论
description: 记录在可逆计算交流群中的一些讨论
authors:
  - flytreleft
---

import {Conversation, Ask, Reply, Note} from '@site/src/components/Conversation';
import Header from '../../\_header.md';

<Header />

> 为避免隐私泄漏，群友问答均以匿名形式组织。另外，为便于阅读和理解，部分问答内容会做相应调整。

<Conversation
asker={{ img: '/img/avatar/anonymous.svg' }}
replier={{ img: '/img/avatar/anonymous.svg' }}>

<Ask>

## 要点整理

</Ask>

<Reply>

[Unison](https://www.unison-lang.org/docs/the-big-idea/)
是算是一种实现技巧吧，根据 content 得到 hash，从而得到一种类似名称，
但是又能指向结构的东西，本身与版本号类似，只是它基于结构本身，
而不是名称来确定唯一性而已。当我们想消除思维中的含混性的时候，
最简单的做法就是进入**相空间**描述，将结构在时间轴上的每个点都区分出来，
但是这样会大大增加整体描述的复杂性。

</Reply>

<Reply>

在现有的技术条件下 GraphQL 是一个很好的选择。
本质上是**信息分布的改变**，原先信息由服务端完全确定，
现在交互信息是服务端和客户端共同决定的，
一部分信息（具体使用哪些字段）这些信息放到了客户端，
也就是说要改变原有信息的组织方式，把 A 和 B 的某种协商作为交互的一部分。

</Reply>

<Reply>

原则上说每个服务（这里指微服务）都不是直接对接的，而是经过某种环境对象交互来发生相互作用的。
所以真正的作用是 `A + B + 环境`，环境本身可以提供柔性适配的功能，
可以注入外部公共知识、公共规则等。

</Reply>

<Reply>

如果要以演化的、松耦合的方式来看待外部世界，那意味着任何时候你看见的都不是对象的全部，
你只知道你需要知道的信息，而你需要知道别的信息的时候可以看到，
你也可以选择以旧的方式继续看待原有的信息。

</Reply>

<Reply>

Delta 需要一个预定义的**坐标系**作为参照物，Delta 只有在同一个坐标系下才能进行合并。
如果我们认为 Delta 是针对整个系统的，就会导致预定义的坐标系过于复杂。

</Reply>

<Reply>

实际上需要将整个系统分解为多个 DSL，然后一个 Delta 包中包含多个 DSL Delta。

</Reply>

<Ask>

## 可逆计算理论有没有可能支持运行期的演化，在用户使用过程中不断完成自我进化

</Ask>

<Reply>

这是一个有趣的问题。先说一下结论：可以，**可逆计算可以应用于运行期演化**。

比如现在 Nop 平台中的设计实际上是延迟编译、即时编译的，如果上线之后我们修改 DSL 模型，
则所有依赖于这个模型的所有模型都会自动失效，下次再访问到这些模型的时候会自动重新加载编译。
例如，如果 `NopAuthUser.xmeta` 被修改了，则 `NopAuthUser.view.xml` 和用到
`NopAuthUser.view.xml` 的所有页面模型也会自动更新。在整个过程中是不需要重新启动系统的，
都是在运行期重新编译即可。SaaS 多租户系统在抽象的层面上看，也可以理解为一个 Delta 定制问题，
每个租户相当于对应于一个 Delta，而且这些 Delta 在运行时的状态空间也是相互隔离的。
实际上，因为 Nop 平台系统化的考虑了 Delta 的构建、分解机制，
相比于其他技术方案它能够更加优雅的处理运行期演化问题。
基于 Nop 平台的设计模式，我们可以实现完全不停机的情况下持续的软件演化。

更为复杂的一个问题是运行期的状态空间是否也能纳入 Delta 的管理范围，
毕竟整个应用系统的完整描述 `= 结构 + 状态`。答案同样是可以，因为可逆计算是一个完全抽象的理论，
它可以将`结构空间 + 状态空间`综合在一起，定义一个完整的高维空间，
然后再考虑这个高维空间中的差量化演化（在物理学中，这个高维空间被称为**相空间**）。
但是从实践的角度上说，**考虑状态将导致需要处理的复杂度直线上升**，
所以一般情况下我们只会考虑结构空间中的 Delta，而忽略状态空间。

具体举一个例子，比如说我们现在要对一个机器人进行 Delta 改进。
对这个机器人的完整描述肯定是包括它的结构，同时还要包括这些结构所处的状态，
比如说它处于高速的运动状态中，我们需要描述它的各个部分的相对速度、加速度、角速度，甚至压力、温度等，
但是我们一般情况下不会在机器人的工作模式下对它进行改装，而是要把它转入到静息模式下，也就是某种非激活的模式，
工作模式下的各种信息对于改装而言是不相关的、可忽略的。少数极端的情况下，我们需要在行驶的火车上换车轮，
那么基本的做法大概是：先使用时间静止技术，在局部冻结时间线，然后将部分需要保持的状态序列化到存储中，
然后修改结构，再次加载状态，一切就绪后再恢复时间演化。
**在 Delta 修正所应用的过程中，时间是静止的，各类状态是冻结的，状态本身也是可以进行 Delta 修正的数据**。
比如说我们使用了某种锁机制，直接阻止外部操作，从外部使用者来看就是时间静止。
更复杂的技术涉及到快照复制，然后在平行宇宙中不断复制 Delta 进行追账，直到对齐到某个时间点，在短时间内静止时间，
完成时间线切换。关于时间静止的一个有趣应用，
可以参见文章[Paxos 的魔法学研究报告](https://zhuanlan.zhihu.com/p/193117183)。

对状态进行 Delta 修正的复杂度在于它并不是仅仅由对象自身决定的，
比如我们的机器人正在和别的机器人进行激烈的战斗，它的状态本质上是与对手相互作用导致的结果，
我们如果需要复现这个状态，必须要考虑到能量守恒、动量守恒、角动量守恒等一系列物理约束，
我们无法单方面的从机器人个体的角度出发复现它的状态，而是必须要考虑所有与它交互的客体的情况，
需要考虑环境与机器人之间的相互影响，这导致复现状态或者修改状态是一件非常复杂的事情。

根据上面的讨论，我们如果希望在运行期实现演化，基本的做法有两种：

1. 分离结构和状态，比如，**微服务本身就是结构而已**，它本身不包含业务状态，所以可以随时启停；
1. 定义激活和非激活两种模式，切换到非激活模式下完成结构修订；

如果发散一下考虑生物界的演化问题。我们可以把 DNA 看作是某种承载信息的 DSL，
生物的成长过程对应于 `Generator`，它根据 DSL 的信息并结合环境信息塑造出生物的本体。
同时生物在应对具体问题挑战的时候，还可以利用外部的各种 Delta。
比如人可以穿上潜水服这个 Delta，获得在水中活动的能力，可以加上不同厚度的衣服，
获得在极寒和极热地区活动的能力。而一般的动植物能够加装的 Delta 很少，
比如飞鸟，如果它在水中长时间潜水，飞行用的翅膀反而是一种阻碍。

</Reply>

<Ask>

## 那针对函数(业务处理逻辑)有可能采用差量机制么？如果可以，那是采用怎样的实现方案，又会面临哪些挑战呢？

函数应该就是 `Generator`

</Ask>

<Reply>

可逆计算的计算模式 `App = Tree x-extends Tree<Tree>`，
`Generator` 作为 AST 抽象语法树也是一个 Tree 结构。
所以业务逻辑只要领域化之后，也是可以定义有意义的差量修正。
Nop 平台中可以通过
[task](https://Gitee.com/canonical-entropy/nop-entropy/blob/master/nop-xdefs/src/main/resources/_vfs/nop/schema/task/task.xdef)
或者 workflow 抽象来进行。
另外在平时实现代码生成器的时候我们会使用 xpl 标签库，标签库中的每个标签函数可以被单独定制。

</Reply>

<Reply>

目前我还在处理规则引擎。业务规则如果用 XML 来表达，可以是：

```xml
<rule>
  <predicate>
    <eq name="status" value="1"/>
    <in name="type" value="${[1,2,3]}"/>
  </predicate>

  <outputs>
    <output name="bizType" value="1"/>
  </outputs>
</rule>
```

</Reply>

<Reply>

规则引擎参见
https://Gitee.com/canonical-entropy/nop-entropy/blob/master/nop-xdefs/src/main/resources/_vfs/nop/schema/rule.xdef
。

</Reply>

<Ask>

## 在系统采用差量机制后，那使用版本机制还有意义么？

</Ask>

<Reply>

Git 的版本相当于是一个比较粗粒度的非结构化差量，
可以给一次大的更新起一个名字，可以处理一般的 java 源码。
而 Delta 我们希望它是高度结构化、语义化的，如果所有的语言包括 Java
都实现合适的 Delta 差量化，则可以起到类似 Git 的作用。

</Reply>

<Reply>

据说 SAP 软件的更新包就是 Delta 化的，可以在不停机的情况下进行代码结构更新。
因为它所有的业务逻辑都是用自己的脚本语言实现的，而状态完全保存在数据库中，
脚本语言的加载器显然可以在加载的时候做很多替换工作。

</Reply>

<Ask>

## 那理想系统的整体工作量还很大，还需要实现一门 Delta 语言

</Ask>

<Reply>

Delta 只是一个特性，只需要在原语言的基础上加部分特性即可。
其实可以在 AspectJ 的基础上做简化就可以实现类-函数级别的 Delta。
C# 语言中的 `PartiaICIass` 也是一种弱化的 Delta。

</Reply>

<Ask>

## 对 Delta 的管理也需要一种基线之类的版本机制吧？或者单独对其使用 Git？

</Ask>

<Reply>

是的，可以用 Git 去管理 Delta。因为很多时候我们就想直接改 Delta 的实现，不需要保留语义边界。

</Reply>

<Ask>

## `xdef.xdef` 中的 `<meta:unknow-tag...>` 为啥是代表任意名称的节点，不是应该就是指定名字是 `unknow-tag` 的节点吗？

</Ask>

<Reply>

在 `xdef.xdef` 中 `meta` 名字空间对应 `xdef`，而 `xdef:unknown-tag` 是平台解析时识别的节点。

</Reply>

<Ask>

那 `<meta:unknown-tag>` 在解析时是不会被识别解析的，但是为什么说是代表任意名称的节点呢？

</Ask>

<Reply>

`unknown-tag` 就是约定表示任意节点。

</Reply>

<Ask>

如果是这么约定的话，那 `xdsl.xdef` 文件，开头为啥非要用 `xdef:unknow-tag`
作为根节点，不是可以随便 `a`、`b`、`c`。

</Ask>

<Reply>

`xdsl.xdef` 表达的是所有 xdsl 领域语言所具有的共性。
`wf`/`beans`/`sql-lib` 这一系列的 xdef 所描述的 dsl 都是 xdsl，
除了它们各自具有的 xdef 元模型定义，它们还同时具有 `xdsl.xdef`
中描述的共性特征。所以 `xdsl.xdef` 中的节点匹配任意节点。

</Reply>

<Ask>

可不可以这么理解，xdef 文件是自定义出来的一种 dsl 语言，并不是严格意义上的
xml，所以不能按照 xml 的思维去理解。比如，`api.xdef` 里面，直接出现 `xdef：xxxx`
这样的属性，但是并没有严格声明 xdef 的名称空间。

</Ask>

<Reply>

是的。Nop 平台中的 xml 是使用 `XNodeParser` 解析的，并没有采用 Java 标准中的
xml 解析器。XNode 对于名字空间进行了简化设计，只考虑根节点上的名字空间，而且不校验内部节点的名字空间。
只有 xdef 的根节点上指定了 `xdef:check-ns` 的时候才检查这些指定名字空间的属性是否在
xdef 元模型中有定义。

</Reply>

<Ask>

那如果用 `XNodeParser` 去解析标准的
xml，遇上属性名称或者节点名称不在某个名称空间里面，也是校验不出来的是吧。

比如 `a` 命名空间下，只有 `x` 这个节点，然后 `<a:y />` 是能过的。

</Ask>

<Reply>

Nop 平台按照可逆计算理论，它的设计永远是 `data + metadata` 配对设计，
也就是任何数据的临近之处总是设计有存放扩展信息的地方，因此 xdsl 语法中规定，
除非特殊指定需要校验名字空间，**所有具有名字空间的属性和节点是不参与校验的**。
这样就可以实现自由扩展，可以在不改变原先模型定义的情况下随时增加 Delta 模型定义。
如果需要检查 Delta 定义满足指定格式，可以自己写一个 xdef，使用
`x:extends` 从原有的 xdef 继承，在自己使用的 xdsl 文件中指定使用自己的 xdef 即可。
平台内置的解析器可以根据指定的新的 xdef 来解析 xml 文件，不需要执行代码生成。

使用 Nop 平台开发的所有功能，包括各类设计器、内部模型，都可以通过 Delta 定制进行扩展。
比如在平台内置的工作流设计器中增加配置属性或者删除已有的配置数据，
都可以通过在 Delta 目录下增加 Delta 定制文件来实现。

:::tip

也就是，`ui:show`、`i18n-en:displayName`
等都属于扩展信息，且本质上也是 Delta，用于附加其他领域空间的配置信息。

:::

</Reply>

<Ask>

那要解析并校验一个外来的 xml，人家本来就有标准 xml 那套
xsdl 名称空间定义，用 `XNodeParser` 去解析校验，还要自己重新造一遍轮子？
写一遍这个 xml 的模型定义 xdef 文件？

当然可能只要造一遍通用的轮子，按说的扩展机制，造一个解析 xsdl 转成
xdef 的扩展出来，再用生成的 xdef 去校验？

</Ask>

<Reply>

`XNodeParser` 并不会识别 `xdef` 名字空间，它只是把 xml 解析为 `XNode`。
一般的 xml 都可以解析，只是不会校验名字空间。`DslModelLoader` 之类的才会识别
`x:schema`，这种情况下，原则上 dsl 文件需要回避 `xdsl`、`xdef` 等内部名字空间，
但是也设计了冲突回避方式，就是使用 `xmlns:xx="/nop/schema/xdef.xdef"`
这种方式来重命名名字空间，比如 `xdef.xdef` 为了避免冲突将 `xdef` 重命名为了 `xmeta`。
但是这种重命名目前没有仔细检查，除了已经使用的少数场景，其他情况下有写死根据名字空间来处理的情况。

</Reply>

<Ask>

## 通过 Delta 可以管理产品主线和客户定制化的关系，与现在的 Git 版本管理不是一样的吗？

产品线难管是因为分支太多，膨胀了，没办法管了。

至于说的 Delta，可以认为 Git 产生的源码 diff，就是一种 Delta，只不过是跟目标环境语言绑死了而已。

</Ask>

<Reply>

不一样。Git 不是面向领域的，所以导致它的冲突概率大得多，多个分支之间的
Delta 定制方向也没有明确定义，导致意图丢失。比如一行中有两个属性修改，Git 就无法自动合并，而
Delta 定制永远都是可以自动合并的，而且通过 `x:override`
可以保持意图。本质上是信息空间中的表达和保持信息守恒的问题。

</Reply>

<Ask>

a 分支要 override 成 a，b 分支要 override 成 b，那还是冲突啊。

</Ask>

<Reply>

如果要按顺序叠加，`base <- a <- b`，这是线性应用的，多层应用按照执行顺序会自动解决冲突问题。
了解一下 trait 为什么可以避免面向对象中多重继承导致的概念冲突问题就明白了。

</Reply>

<Reply>

1. 首先使用自定义结构空间而不是预设的通用行空间、类空间；
1. DSL 相当于定义了一种领域特定的坐标系，在这个坐标系中可以精确定义定点的 Delta 变化。
   可以类比物理中的狄拉克 Delta 函数去理解；

</Reply>

<Ask>

按顺序叠加这块明白了，冲突是没了，这样叠加完之后，得到的结果其实并不是用户最终要的，还得再叠加自己的东西上去。

</Ask>

<Reply>

本来就是这样。`Delta_a + Delta_b` 并不一定满足要求，这里可以通过增加额外的
` Delta_c` 来解决冲突问题。在 Feature Oriented Programming 的语境中
Batory 发明了一个所谓概念叫做 quark 来表达对这种冲突的识别和处理。

</Reply>

<Ask>

但是这种差异的识别也很难，顾客看到了一个产品的两个差异版本，他是不知道底层是多少个
Delta 组成的，他只会提出，需要这个版本里面的 xxxx，然后那个版本里面 yyy，合在一起就好了。

但是 xxxx，和 yyy 到底又有多少 Delta 组成的，这个其实最终跟分析源代码也没啥两样。

</Ask>

<Reply>

这样要求 Delta 满足交换律，本身如果的 Delta 不冲突，那么它们自然是满足交换律的，
否则的话 `a + b` 和 `b + a` 是不同的，本身就需要额外再增加 Delta 来补齐。

</Reply>

<Ask>

其实产品线合并的痛点在这里。

</Ask>

<Reply>

产品线合并的痛点在于**没法将产品化的部分和定制化的部分分离**。可以分成
platform/product/deploy 这几个 Delta，然后对平台的修正和对产品的修正就可以独立于的部署修正隔离开来。
这些本身也需要一定的规划，不是随便乱来的。

</Reply>

<Ask>

其实怕的就是最后一层 deploy 的那个真的是五花八门，合起来必然有冲突。

</Ask>

<Reply>

可逆计算的观念是通过最外层的 Delta 来吸收偶然性需求，保护基础框架和 Base Delta 的稳定。
无法控制熵增也可以控制熵增的地方，这才是关键。
Delta 合并不会出现形式冲突，合并后必然满足 xdef 元模型要求，可以执行语义校验。

</Reply>

<Reply>

首先应用大了还是会分不同的业务模块，领域模型。
然后差量并不是用来组装不同业务功能点最终合成一个大产品，
而是对某一个业务模块的不同层次的差量定制。
最常用的应该就一个基础版本加一层差量，能做的扩展性就已经非常大了。

</Reply>

<Reply>

要是延续之前做法，确实不好。业务域也需要分割好。然后一步一步组装起来。

</Reply>

<Reply>

是的，**差量不是用来进行分模块逻辑组织的**。
就好像不要使用继承来进行分模块逻辑组织。
Delta 是用来解决可扩展性问题，解决含时演化的。

</Reply>

<Reply>

Delta 定制解决的问题是系统已经打包发布之后，无需修改原有代码，可以随意定制已有的所有功能。
所以平台的二次开发是无需修改平台代码的。
目前没有其他技术具有这个能力，它解决的问题也是传统技术所无法解决的问题。

</Reply>

<Reply>

Nop 平台目前就提供了粗粒度软件复用的机制，可以在不修改一个非常大的
X 的基础上，通过补充 Delta，将它转化成 Y。而所谓的可扩展性，本质上就是不修改
X，通过补充新的信息来达到生产新的功能的目的。

</Reply>

<Reply>

可逆计算主要涉及到的是**编译期形式变换**，运行时形式封装只是一个次要的问题。

</Reply>

<Ask>

## DSL 最终要被生成成特定的语言，这样，Detla 定制就绕不开语言？

就好比现在的 Nop 平台是 Java 实现的，当需要做一个 Detla 叠加时，
好像没办法用 Python 或者其他语言就 override 或者修正某一部分 Delta。
尤其在外层修改原有功能时，必须还是要去考虑原有层的代码。

</Ask>

<Reply>

并不是这样。Nop 平台的做法相当于是标准化 Delta 空间。传统上的 Delta
都是针对特定业务领域、特定框架设计的，比如 Spring 中有 `parent`、`abstract`
等属性，需要解析得到 `BeanDefinition` 对象然后处理，GraphQL 有 extendtype
等扩展定义，需要解析得到 `GraphQLObjectDefinition` 等对象后进行处理。
但是可逆计算理论是指出在对象层之前存在统一的、厚重的结构层，
恰如各式各样不同的建筑风格最终都使用统一的结构力学来构建。
所以本质上 Nop 平台中的做法是跨语言、跨框架的，它通过统一的 `XNode` 接口来规范化结构层，然后定义了
`XNode` 和 XML、JSON 等通用结构的双向映射关系，可以自动实现可逆变换，然后再逐步定义
JSON 和 Java 之间，JSON 和 Excel 之间，JSON 和数据库之间的双向映射。

</Reply>

<Reply>

关键的关键是无需考虑任何运行时框架的语义，在纯粹的 `XNode`
结构层面（形式层面）就可以完成所有可逆计算所要求的 Delta 运算。
无论是工作流引擎、报表引擎、ORM 引擎等都是统一使用同样的 `XNode` 结构。

</Reply>

<Ask>

其实就是全部面向 DSL 开发，Generator 就是虚拟机。

</Ask>

<Reply>

Nop 平台整体解决问题是两阶段方式：

1. 定义领域专用的 DSL；
1. 用 DSL 去承载业务；

DSL 可以在 XML/JSON/Excel/数据库/可视化设计器 等多种表示形式之间自由转换。
也可以**通过 Generator 最终转换为某种程序代码**。
但是这种生成是业务无关的，可以脱离业务一次性完成。

</Reply>

<Reply>

如果学习过物理学中的张量概念就会知道，理论的概念是唯一的，
但是它可以投射到不同的具体的坐标系中产生不同的表象，而不同表象之间可以自由转换。
所以 Nop 平台的做法很简单，
就是存在信息的某种类似张量的与具体坐标系无关的（与语言、框架、运行时无关）表示，
然后再定义它到具体的形式之间的表象（相当于是投射到某种坐标系中，**一种语言就定义了一种坐标系**）。

</Reply>

<Reply>

这些都是物理学中的概念，可以把上面的文章中关于 Talyer 级数的直觉解释仔细看一下。
努力的方向是，**信息可以跨形式自由转换**，而不是一旦写成代码就禁锢在某种框架、某种语言、某种运行时中。

</Reply>

<Reply>

物理学的定律是所谓坐标系无关的，这是爱因斯坦所提出的最重要的物理思想。
定律的**张量形式不随坐标系变换而发生变化**。但是在使用具体的坐标表达时，物理学的公式形式是在不断变化的，
但是一旦整理成张量形式，给张量指定一个抽象的符号，那么无论怎么变换这个符号都是不变的。

</Reply>

<Reply>

物理学中的张量与深度学习中的张量概念在内涵上是不一样的，不是同一个东西，但是有关联。

</Reply>

<Reply>

物理学中所有的基本概念都是坐标系无关的，但是所有具体问题的表述都要依赖坐标系，
那怎么能说物理定律与坐标系无关呢？这里的无关真正的含义是同样的物理定律在不同的坐标系中具有不同的形式，
恰如同样的业务在不同的框架、不同的语言中表达式也具有不同的形式，但是这些不同的形式背后存在统一的抽象内容，
可以使用张量概念进行统一描述，然后把它投射到不同的坐标系中就自动产生了不同的具体表达。
可逆计算所实现的是业务的技术中立的表达，然后通过一系列的可逆转换实现它向不同坐标系的投射。
当然这种技术中立的表达本身也是需要一个坐标系的，也就是内置的 XLang 语言（包括 xlib,xpl,xdef,xdsl 等），
但是 xdsl 相当于是物理学中的内禀坐标系，一种在领域内部具有某种最优性的坐标系。
这种最优性可以通过需求变动时如何变化最少量的表达量来精确的度量，在信息论的角度上说可以进行某种精确的定义。

</Reply>

<Reply>

现代数学与古典数学的一个本质性区别在于，现代数学是建立在等价类概念基础之上的，
当们说到任何一个数学对象时，指的都不是某个特定的数学对象，
而是在某种等价规则定义下的一系列相互等价的具体对象所构成的等价类。

</Reply>

<Reply>

我们习以为常的 1，2，3 这种数学上最常见的基础对象，在严格的数学论述中也是每个数字都是由无穷多的对象所组成的等价类。

</Reply>

<Reply>

彭罗斯在《通向实在之路》一书中介绍了一个有趣的事情。他母亲的一位朋友（芭蕾舞演员）完全不能理解分数：
为什么 `1/2 = 2/4`，这两边明明差别很大，为什么会是一样的呢？
彭罗斯经过仔细思考发现了其中的华点：虽然他母亲的这位朋友可以说对数学一无所知，
但却通过敏锐的观察力洞察了现代数学的秘密。分数的现代定义是将 `1/2, 2/4, 3/6, ....`
这样的无穷序列看作是一个等价类，然后在这个等价类中选择形式最简单的 `1/2` 作为它的代表元，
每当们使用这个等价类的时候，们都可以用这个代表元来表示。

《通向实在之路》是一本很有趣的科普著作。如果读懂了这本书，可逆计算中涉及到的一些简单的物理数学观念就是不言自明的了。

</Reply>

</Conversation>
