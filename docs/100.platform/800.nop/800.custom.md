---
title: 定制化开发
description: 与定制化开发相关的内容
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

## 注意事项 {#notes}

- 可以通过实现 `IResourceNamespaceHandler` 的方式，
  自定义资源加载接口，从而实现对不同组织结构和方式的资源的加载
  - 在资源路径前添加前缀的方式识别，如 `delta_layer:/xx/xx/xx.xml`
  - 调用
    `VirtualFileSystem.instance().registerNamespaceHandler(IResourceNamespaceHandler)`
    进行注册
  - 通过 `io.nop.core.resource.store.VfsConfig#pathMappings`
    可以做虚拟路径转换，将 `_vfs` 下的文件隐射到其他目录下的同名文件（相对路径一致）
- 标准资源路径见: `docs/dev-guide/vfs/std-resource-path.md`
- `enum` 类型的使用方式还未确定，目前只支持使用枚举类型 `enum:io.xx.xx.Type`
- `io.nop.core.lang.eval.global.EvalGlobalRegistry#EvalGlobalRegistry`
  中定义了在 xpl 中可引用的全局变量
- 配置的加载逻辑在 `io.nop.config.starter.ConfigStarter#doStart`
  中，其支持从配置中心获取配置。可以通过激活的 profile 名称，创建不同环境的配置文件，如
  `application-dev.yaml`，其文件名为 `application-${profile}.yaml` 形式
- 在 `io.nop.biz.dev.DevDocBizModel` 中定义了配置、全局函数、Beans、GraphQL
  等数据的查看接口

## `XCodeGenerator` 的阶段构建 {#code-gen-building}

默认定义的 XDSL 并不会生成 Java Class，若是模型结构需要以代码形式使用，
则需要通过 `XCodeGenerator` 从 XDSL 生成代码。

在开发过程中可以在 Maven 构建阶段生成，也可以在单元测试中调用
`XCodeGenerator` 的生成函数。二者本质是一样的，只是执行时机不同：

- Maven 方式是在代码构建时才生成，每次修改 dsl 后，都需要执行
  `mvn compile` 命令
- 在单元测试中的方式，可以在运行测试用例时自动生成最新代码

无论何种方式，都需要在 Maven 模块的根目录内创建以 Maven 构建阶段名称命名的目录，
并在其中放置 `xgen` 脚本。

不同的 Maven 构建阶段，具有不同的特性，需要根据实际情况编写不同的构建逻辑：

- `precompile`：预构建的第一阶段，在该阶段还未将 `src/main/resources`
  目录中的资源复制到 `target` 目录下，也就不能在该阶段访问到当前项目的
  classpath 资源，故而，在该目录的 `xgen` 脚本中，不能为当前项目中的
  XDSL 生成代码
- `precompile2`：预构建的第二阶段，在该阶段中，`src/main/resources`
  下的资源已经复制到 `target` 目录下，可以访问当前项目中的 classpath
  资源，故而，只能在该阶段为本项目内的 XDSL 生成代码
- `postcompile`：构建完成的后处理，可以执行一些非代码相关的构建

若是在单元测试中自动生成或更新 XDSL 的代码，可以在 `@BeforeAll`
函数中调用如下代码：

```java
File projectDir = MavenDirHelper.projectDir(XxxTest.class);

XCodeGenerator.runPrecompile(projectDir, "/", false);
XCodeGenerator.runPrecompile2(projectDir, "/", false);
XCodeGenerator.runPostcompile(projectDir, "/", false);
```

> 由于运行单元测试时，本项目内的资源均在 classpath 内，
> 故而，无需区分构建阶段，只需要依次运行全部 `xgen` 脚本即可

在 `xgen` 脚本中生成 XDSL 代码的内容如下：

```xml title="/precompile2/gen-xdsl.xgen"
<c:script xmlns:c="c"><![CDATA[
  codeGenerator.renderModel('/xxx/schema/web/site.xdef', '/nop/templates/xdsl', '/', $scope);
  codeGenerator.renderModel('/xxx/schema/web.xdef', '/nop/templates/xdsl', '/', $scope);
]]></c:script>
```

- `codeGenerator` 为当前代码生成器 `XCodeGenerator` 变量，在
  `XCodeGenerator#execute` 中定义
- `$scope` 为在 `EvalGlobalRegistry` 中注册的全局变量
  `ScopeGlobalVariable`，代表当前的构建作用域
- 在 `*.xdef` 内外联其他 XDef 时，需要显式调用 `XCodeGenerator#renderModel`
  生成代码，默认不会对外联的 XDef 生成代码
- Maven 构建内置的变量在 `CodeGenTask#execute` 中定义
- 在 XDef 中可以访问生成函数 `XCodeGenerator#renderModel` 中定义的变量

## `x:gen-extends` 的使用 {#gen-extends-usages}

`x:gen-extends` 在 XDSL 中使用，用于动态展开其生成节点树，并与其所在的父节点做合并。

其有如下几种使用方式：

```xml title="方式一"
  <!-- ... -->
  <title>
    <x:gen-extends>
      <any>${'Nop 平台'}</any>
    </x:gen-extends>
  </title>
```

```xml title="方式二"
  <!-- ... -->
  <title>
    <x:gen-extends>
      <c:script><![CDATA[
        const title = 'Nop 平台';
      ]]></c:script>

      <any>${title}</any>
    </x:gen-extends>
  </title>
```

以上方式的最终结果均为 `<title>Nop 平台</title>`。

也就是，`x:gen-extends` 生成的节点树将与其所在的父节点做合并，
而生成树的根节点可以为任意标签（样例中为 `any`）。
在涉及复杂计算处理时，一般将逻辑放在 `c:script` 中，
并在生成树中通过 `${}` 引用在 `c:script` 中定义的 `let`
或 `const` 变量。

> 如果，`x:gen-extends` 所在的节点是 XDSL 的根节点，
> 则其生成树的根节点需要与 XDSL 根节点的标签名称相同。

## 编写 `x:gen-extends` 的运行代码 {#write-gen-extends-execution-code}

如果是在 xpl 模板内：

```xml title="/path/to/site-html.xgen"
<x:gen-extends
  xmlns:x="/nop/schema/xdsl.xdef"
  xmlns:xpl="xpl" xmlns:web="web"
>

  <web:GenSiteHtml site="${site}" xpl:lib="/web/xlib/web.xlib" />
</x:gen-extends>
```

则先通过 `XLangCompileTool` 编译，再执行函数：

```java {4,7,11,14}
XLangCompileTool compiler = XLang.newCompileTool();
// Note：在编译 xpl 时需要获取 ${} 中的变量，但在编译器中无法注入该变量，
// 故而，需要忽略未注册变量，以确保编译能够正常进行
compiler.getScope().setAllowUnregisteredScopeVar(true);

XNode node = XNodeParser.instance().parseFromVirtualPath("/path/to/site-html.xgen");
ExprEvalAction action = compiler.compileTagBody(node, XLangOutputMode.node);

// 注入变量
IEvalScope scope = XLang.newEvalScope();
scope.setLocalValue("site", site);

// 执行 xpl 函数并得到 XNode 树
XNode htmlNode = action.generateNode(scope);
String html = htmlNode.innerHtml();
```

而如果是在 XDSL 中：

```xml title="/path/to/site-html.xml"
<html xmlns:x="/nop/schema/xdsl.xdef"
      xmlns:xpl="xpl" xmlns:web="web"
      x:schema="/schema/web/html.xdef"
>

  <x:gen-extends>
    <web:GenSiteHtml site="${$site}" xpl:lib="/web/xlib/web.xlib" />
  </x:gen-extends>
</html>
```

则直接使用 `DslModelParser` 解析 XDSL 即可，`x:gen-extends` 将自动执行：

```java
XNode node = XNodeParser.instance().parseFromVirtualPath("/path/to/site-html.xml");
String xdefPath = node.attrText("x:schema");

DslModelParser parser = new DslModelParser(xdefPath);
DynamicObject obj = (DynamicObject) parser.parseFromNode(node);

XNode htmlNode = DslModelHelper.dslModelToXNode(xdefPath, obj);
String html = htmlNode.html();
```

需要注意的是，在 XDSL 中，`x:gen-extends` 只能引用全局变量，而全局变量需要通过
`EvalGlobalRegistry.instance().registerVariable(...)` 进行注册，并且变量名称需以
`$` 开头。该全局变量是所有线程共享的，对于临时变量的注入，需要通过 `ThreadLocal`
来暂存。

## 创建最小 Quarkus 应用服务启动器 {#create-mini-quarkus-app-starter}

> 该启动器基于对 Nop 平台的 `nop-quarkus/nop-quarkus-core-starter`
> 和 `nop-quarkus/nop-quarkus-web-starter` 模块的合并改造而成。

Quarkus 应用服务启动器需满足以下要求：

- 以独立依赖包方式引入具体的应用服务 Maven 模块中，
  引入后便可以构建 Quarkus 应用可执行 jar 包，
  并且也可以在 IDE 中运行调试
- 支持 Nop Ioc 机制，可以将定义在应用服务依赖模块中的 beans
  加载到 Quarkus 运行环境中
- 自动初始化 Nop 环境，自动加载 `IHttpServerFilter`
  过滤器，从而支持基于 Nop 的应用服务的运行
- 仅需打包 jar，不打包可执行文件或 Docker 容器镜像

首先，创建共用的启动器核心模块 `quarkus-starter`，并添加项目的最小依赖：

```xml title="quarkus-starter/pom.xml"
  <!-- ... -->
  <dependencies>
    <dependency>
      <groupId>io.github.entropy-cloud</groupId>
      <artifactId>nop-boot</artifactId>
    </dependency>
    <dependency>
      <groupId>io.github.entropy-cloud</groupId>
      <artifactId>nop-http-api</artifactId>
    </dependency>

    <!-- 使用 caffeine 提供的 graalvm 支持 -->
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-caffeine</artifactId>
    </dependency>
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-config-yaml</artifactId>
    </dependency>
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-arc</artifactId>
    </dependency>
    <!--
    Note：需要排除 quarkus-bootstrap-core（被 quarkus-core-deployment 依赖），
    否则在 IDE 中启动 @QuarkusMain 的 main 函数会失败，只能用 quarkus 插件启动
    -->
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-vertx-http</artifactId>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <!--
      创建 *.class 索引，并记录在 META-INF/jandex.idx 中。
      必须创建 class 索引，否则，在运行 Quarkus 应用时，将不能扫描到
      _vfs/nop/autoconfig 中的 beans 定义，从而导致无法通过
      Nop Ioc 创建 bean
      -->
      <plugin>
        <groupId>org.jboss.jandex</groupId>
        <artifactId>jandex-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
```

直接将 Nop 平台中的以下 class 复制到 `quarkus-starter` 模块中：

- `HttpServerFilterRegistrar`：注册 `IHttpServerFilter` 过滤器
- `VertxHttpServerContext`：基于 Quarkus Vertx 的上下文
  `IHttpServerContext` 实现
- `NopQuarkusBeanContainer`：基于 Quarkus 的 bean 容器
  `IBeanContainer` 的实现
- `QuarkusExecutorHelper`：创建 Quarkus 异步任务
- `QuarkusIntegration`：初始化 Nop 平台配置，并注册
  `NopQuarkusBeanContainer`

然后，创建启动器辅助对象 `QuarkusStarter`，用于执行通用的启动和结束逻辑：

```java title="QuarkusStarter.java"
public class QuarkusStarter {

  public static int start(String... args) throws Exception {
    QuarkusIntegration.start();

    NopApplication app = new NopApplication();

    // #run 默认是执行完后便返回的，
    return app.run(args, () -> {
      // 故而，需要一直等待应用服务进程的结束
      Quarkus.waitForExit();
      return 0;
    });
  }

  public static void stop(int exitCode, Throwable e) {
    CoreInitialization.destroy();
  }
}
```

接着，创建应用服务可执行包的打包模块：

```xml {4-5,10,20,28} title="pom.xml"
  <!-- ... -->
  <properties>
    <!-- 该模块为独立服务包，不会被其他项目所依赖，故，不发布至仓库 -->
    <maven.deploy.skip>true</maven.deploy.skip>
    <maven.install.skip>true</maven.install.skip>
  </properties>

  <dependencies>
    <dependency>
      <artifactId>quarkus-starter</artifactId>
    </dependency>

    <!-- ... -->
  </dependencies>

  <profiles>
    <profile>
      <id>quarkus</id>
      <activation>
        <activeByDefault>true</activeByDefault>
      </activation>
      <properties>
        <!--
        配置 Quarkus 的默认打包类型: https://quarkus.io/guides/building-native-image
        - native: Docker 镜像打包
        - uber-jar: 单一可执行的 jar 包
        - fast-jar: 各依赖包分类放置的组织形式，方便复用公共基础 jar，执行入口为
          target/quarkus-app/quarkus-run.jar
        -->
        <quarkus.package.type>uber-jar</quarkus.package.type>
      </properties>
    </profile>
  </profiles>

  <build>
    <plugins>
      <plugin>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-maven-plugin</artifactId>
        <version>${quarkus.platform.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>build</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
```

由于 Quarkus 的启动器不能在依赖包中实现（在依赖包中实现时，将不能扫描到应用服务中的
classpath 资源），故而，需要再在该各个应用服务模块内创建一个最简的
Quarkus 启动器 `AppStarter`：

```java {1,6,11} title="AppStarter.java"
@QuarkusMain
public class AppStarter implements QuarkusApplication {

  public static void main(String... args) {
    // https://quarkus.io/guides/lifecycle#the-main-method
    Quarkus.run(AppStarter.class, QuarkusStarter::stop, args);
  }

  @Override
  public int run(String... args) throws Exception {
    return QuarkusStarter.start(args);
  }
}
```

> 该启动器需实现 `QuarkusApplication` 接口，并在 `Quarkus#run`
> 的第二个参数提供退出清理函数。

至此，最小的 Quarkus 应用服务启动器便创建完成。

剩下的，便可以在应用服务模块内引入外部的 `IHttpServerFilter`
实现，或者，在该模块内通过 `@Observes` 等添加与 Quarkus
相关的适配逻辑。

此外，应用服务的本地配置定义在 `src/main/resources`
中的 YAML 文件中：

- `bootstrap.yaml`：应用服务的启动配置，通过
  `CoreInitialization#loadBootstrapConfig` 载入。
  在其中按配置变量 `quarkus.profile` 的值做多环境配置，
  且根键为 `"%${profile}"` 形式，其中，`${profile}`
  为 `quarkus.profile` 的值
- `application.yaml`：应用服务的运行配置，可设置
  Quarkus 和 Nop 的配置数据
- `application-${profile}.yaml`：与配置变量 `quarkus.profile`
  对应的配置文件，当 `${profile}` 与 `quarkus.profile`
  的值相同时，便会加载该配置文件中的配置数据。可用于多环境配置的需求场景

```yaml title="bootstrap.yaml"
"%dev":
  # 跟踪系统内的 Java 反射调用，并自动生成 Graalvm 原生镜像所需的的配置文件，
  # 如，proxy-config.json、reflect-config.json、nop-vfs-index.txt 等。
  # 其定义在 io.nop.codegen.CodeGenConfigs.CFG_CODEGEN_TRACE_ENABLED，
  # 需要在依赖中引入 nop-codegen 模块，并确保模块根据目下的子目录
  # precompile/precompile2/postcompile 不全部为空
  nop.codegen.trace.enabled: true
```

## Nop Beans 的创建与加载 {#nop-beans-creation-and-loading}

Nop 平台提供 Ioc 机制，用于 Java Beans 的创建和依赖注入。

所有的 Java Beans 都以 XDSL 进行声明，并且同样支持差量合并等特性。

要使用该机制，首先需要引入 `nop-ioc` 依赖：

```xml title="pom.xml"
  <!-- ... -->
  <dependencies>
    <!-- ... -->

    <!-- 支持注入 _vfs/nop/autoconfig/*.beans 中定义的 beans -->
    <dependency>
      <groupId>io.github.entropy-cloud</groupId>
      <artifactId>nop-ioc</artifactId>
    </dependency>
  </dependencies>
```

然后，在 Nop 虚拟文件系统中创建 `/nop/autoconfig/xxx.beans`，
并在其中指定 Beans XDSL 的位置：

```txt title="src/main/resources/_vfs/nop/autoconfig/xxx.beans"
/xxx/xxx/beans/default.beans.xml
```

> `*.beans` 与 `*.beans.xml` 的名称可按需自定义。

最后，在 `*.beans.xml` 中定义需要创建的 Beans：

```xml title="src/main/resources/_vfs/xxx/xxx/beans/default.beans.xml"
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:x="/nop/schema/xdsl.xdef" xmlns:ioc="ioc"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"
       x:schema="/nop/schema/beans.xdef"
>

  <bean id="webSiteHttpServerFilter"
        class="org.xxx.web.filter.WebSiteHttpServerFilter"
        ioc:default="true">
    <property name="provider" ref="webSiteProvider" />
  </bean>

  <bean id="webSiteProvider"
        class="org.xxx.web.WebSiteProvider">
  </bean>
</beans>
```

`*.beans.xml` 为 Nop 平台的 XDSL，并且定义在其虚拟文件系统之上，
可以与其他 XDSL 一样对定义的 Beans 做差量修订，
实现对已有项目的定制化处理。

注意，一般要求 `/nop/autoconfig/xxx.beans` 与
`/xxx/xxx/beans/default.beans.xml` 在不同模块之间应该具备唯一性，
从而便于在 Delta 层对某个模块做差量处理，避免文件名称相同而无法定位差量。

## Nop GraphQL 的启用 {#enable-nop-graphql}


