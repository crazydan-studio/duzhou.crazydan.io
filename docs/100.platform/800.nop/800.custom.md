---
title: 定制化开发
description: 与定制化开发相关的内容
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

## 注意事项 {#notes}

- 可以通过实现 `IResourceNamespaceHandler` 的方式，
  自定义资源加载接口，从而实现对不同组织结构和方式的资源的加载
  - 在资源路径前添加前缀的方式识别，如 `delta_layer:/xx/xx/xx.xml`
  - 调用
    `VirtualFileSystem.instance().registerNamespaceHandler(IResourceNamespaceHandler)`
    进行注册
  - 通过 `io.nop.core.resource.store.VfsConfig#pathMappings`
    可以做虚拟路径转换，将 `_vfs` 下的文件隐射到其他目录下的同名文件（相对路径一致）
- 标准资源路径见: `docs/dev-guide/vfs/std-resource-path.md`
- `enum` 类型的使用方式还未确定，目前只支持使用枚举类型 `enum:io.xx.xx.Type`
- `io.nop.core.lang.eval.global.EvalGlobalRegistry#EvalGlobalRegistry`
  中定义了在 xpl 中可引用的全局变量

## `XCodeGenerator` 的阶段构建 {#code-gen-building}

默认定义的 XDSL 并不会生成 Java Class，若是模型结构需要以代码形式使用，
则需要通过 `XCodeGenerator` 从 XDSL 生成代码。

在开发过程中可以在 Maven 构建阶段生成，也可以在单元测试中调用
`XCodeGenerator` 的生成函数。二者本质是一样的，只是执行时机不同：

- Maven 方式是在代码构建时才生成，每次修改 dsl 后，都需要执行
  `mvn compile` 命令
- 在单元测试中的方式，可以在运行测试用例时自动生成最新代码

无论何种方式，都需要在 Maven 模块的根目录内创建以 Maven 构建阶段名称命名的目录，
并在其中放置 `xgen` 脚本。

不同的 Maven 构建阶段，具有不同的特性，需要根据实际情况编写不同的构建逻辑：

- `precompile`：预构建的第一阶段，在该阶段还未将 `src/main/resources`
  目录中的资源复制到 `target` 目录下，也就不能在该阶段访问到当前项目的
  classpath 资源，故而，在该目录的 `xgen` 脚本中，不能为当前项目中的
  XDSL 生成代码
- `precompile2`：预构建的第二阶段，在该阶段中，`src/main/resources`
  下的资源已经复制到 `target` 目录下，可以访问当前项目中的 classpath
  资源，故而，只能在该阶段为本项目内的 XDSL 生成代码
- `postcompile`：构建完成的后处理，可以执行一些非代码相关的构建

若是在单元测试中自动生成或更新 XDSL 的代码，可以在 `@BeforeAll`
函数中调用如下代码：

```java
File projectDir = MavenDirHelper.projectDir(XxxTest.class);

XCodeGenerator.runPrecompile(projectDir, "/", false);
XCodeGenerator.runPrecompile2(projectDir, "/", false);
XCodeGenerator.runPostcompile(projectDir, "/", false);
```

> 由于运行单元测试时，本项目内的资源均在 classpath 内，
> 故而，无需区分构建阶段，只需要依次运行全部 `xgen` 脚本即可

在 `xgen` 脚本中生成 XDSL 代码的内容如下：

```xml title="/precompile2/gen-xdsl.xgen"
<c:script xmlns:c="c"><![CDATA[
  codeGenerator.renderModel('/xxx/schema/web/site.xdef', '/nop/templates/xdsl', '/', $scope);
  codeGenerator.renderModel('/xxx/schema/web.xdef', '/nop/templates/xdsl', '/', $scope);
]]></c:script>
```

- `codeGenerator` 为当前代码生成器 `XCodeGenerator` 变量，在
  `XCodeGenerator#execute` 中定义
- `$scope` 为在 `EvalGlobalRegistry` 中注册的全局变量
  `ScopeGlobalVariable`，代表当前的构建作用域
- 在 `*.xdef` 内外联其他 XDef 时，需要显式调用 `XCodeGenerator#renderModel`
  生成代码，默认不会对外联的 XDef 生成代码
- Maven 构建内置的变量在 `CodeGenTask#execute` 中定义
- 在 XDef 中可以访问生成函数 `XCodeGenerator#renderModel` 中定义的变量

## `x:gen-extends` 的使用 {#gen-extends-usages}

`x:gen-extends` 在 XDSL 中使用，用于动态展开其生成节点树，并与其所在的父节点做合并。

其有如下几种使用方式：

```xml title="方式一"
  <!-- ... -->
  <title>
    <x:gen-extends>
      <any>${'Nop 平台'}</any>
    </x:gen-extends>
  </title>
```

```xml title="方式二"
  <!-- ... -->
  <title>
    <x:gen-extends>
      <c:script>
        const title = 'Nop 平台';
      </c:script>

      <any>${title}</any>
    </x:gen-extends>
  </title>
```

以上方式的最终结果均为 `<title>Nop 平台</title>`。

也就是，`x:gen-extends` 生成的节点树将与其所在的父节点做合并，
而生成树的根节点可以为任意标签（样例中为 `any`）。
在涉及复杂计算处理时，一般将逻辑放在 `c:script` 中，
并在生成树中通过 `${}` 引用在 `c:script` 中定义的 `let`
或 `const` 变量。

> 如果，`x:gen-extends` 所在的节点是 XDSL 的根节点，
> 则其生成树的根节点需要与 XDSL 根节点的标签名称相同。

## 编写 `x:gen-extends` 的运行代码 {#write-gen-extends-execution-code}

如果是在 xpl 模板内：

```xml title="/path/to/site-html.xgen"
<x:gen-extends
  xmlns:x="/nop/schema/xdsl.xdef"
  xmlns:xpl="xpl" xmlns:web="web"
>

  <web:GenSiteHtml site="${site}" xpl:lib="/web/xlib/web.xlib" />
</x:gen-extends>
```

则先通过 `XLangCompileTool` 编译，再执行函数：

```java {4,7,11,14}
XLangCompileTool compiler = XLang.newCompileTool();
// Note：在编译 xpl 时需要获取 ${} 中的变量，但在编译器中无法注入该变量，
// 故而，需要忽略未注册变量，以确保编译能够正常进行
compiler.getScope().setAllowUnregisteredScopeVar(true);

XNode node = XNodeParser.instance().parseFromVirtualPath("/path/to/site-html.xgen");
ExprEvalAction action = compiler.compileTagBody(node, XLangOutputMode.node);

// 注入变量
IEvalScope scope = XLang.newEvalScope();
scope.setLocalValue("site", site);

// 执行 xpl 函数并得到 XNode 树
XNode htmlNode = action.generateNode(scope);
String html = htmlNode.innerHtml();
```

而如果是在 XDSL 中：

```xml title="/path/to/site-html.xml"
<html xmlns:x="/nop/schema/xdsl.xdef"
      xmlns:xpl="xpl" xmlns:web="web"
      x:schema="/schema/web/html.xdef"
>

  <x:gen-extends>
    <web:GenSiteHtml site="${$site}" xpl:lib="/web/xlib/web.xlib" />
  </x:gen-extends>
</html>
```

则直接使用 `DslModelParser` 解析 XDSL 即可，`x:gen-extends` 将自动执行：

```java
XNode node = XNodeParser.instance().parseFromVirtualPath("/path/to/site-html.xml");
String xdefPath = node.attrText("x:schema");

DslModelParser parser = new DslModelParser(xdefPath);
DynamicObject obj = (DynamicObject) parser.parseFromNode(node);

XNode htmlNode = DslModelHelper.dslModelToXNode(xdefPath, obj);
String html = htmlNode.html();
```

需要注意的是，在 XDSL 中，`x:gen-extends` 只能引用全局变量，而全局变量需要通过
`EvalGlobalRegistry.instance().registerVariable` 进行注册，并且变量名称需以
`$` 开头。该全局变量是所有线程共享的，对于临时变量的注入，需要通过 `ThreadLocal`
来暂存。
