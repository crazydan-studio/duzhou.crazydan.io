---
title: 功能特性
description: 了解本平台的功能特性
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

本平台的核心能力涉及应用生命周期的以下几个方面：

- 应用开发：包括设计、编码、调试、测试
  - 应用演化支持
  - 测试：包括单元测试、集成测试
- 应用运维：包括部署、调度、诊断、更新、下线
  - 更新：涉及服务配置、代码片段、应用本体。
    实现技术包括热更新、访问分流
  - 诊断：使用 [Arthas](https://arthas.aliyun.com/)
    等工具进行在线分析和临时性修复
- 应用监控：包括日志、性能
  - 从操作触发开始，将监控数据组织为树结构：
    涉及服务间调用、异步。通过 `Trace ID` 进行跟踪识别
  - 日志：包括用户操作、代码执行
  - 性能：涉及调用链、执行时长、参数与返回

但是，本平台重点关注的是应用生命周期的各个阶段的串联过程，
而具体实现技术则是可自由替换和优化改进的。
也就是，一个囊括应用全生命周期的平台需**要做什么**才是其核心关注点，
而具体**怎么做**则是与多种工具和实现技术相结合的，
平台不会做出限制和约束，在具体的场景下可以对实现进行逐步优化。

## 功能点

- 基于**可逆计算**
  - 演化式应用：差量定制、差量变更、差量开发
- 多租户
- 可微服务、可单体
- 自运维、自监控
- 应用 DSL 化，即从业务层面自顶向下逐层设计和分解 DSL，
  从而实现功能级别的复用和重组，避免代码层级的复用而带来的高复杂度。
  一组具有完整功能的 DSL 集合即称之为 **部件**（Parts）
  - DSL 或差量通过其 AST Hash 作为其版本和唯一性标识，
    在其之上做的差量修改需引用该 Hash 值以记录引用关系，
    类似 Git 的变更历史
  - 通过 SQLite 记录这些关系
- 自动生成接口文档、模型结构文档、部件依赖
- 由平台展开和编译 DSL 为可执行代码，再向目标设备部署服务
  - 自动采取蓝绿部署等方案，实现新旧服务的平滑过渡
- 对部件市场的各类部件提供演示部署服务，以便于查看和体验部件的能力
- 支持识别并复制对象 **坐标**，从而便于生成和管理差量内容
  - 提供 VSCode 插件，以图形化方式进行差量操作：简单的线框图即可
- 国际化支持：前后端方案，资源可复用
  - 可采用差量机制，在运行时根据语言环境动态应用不同语言的差量，合并生成最终页面，
    也可以在编译期为不同语言生成不同的最终页面，用户访问时根据客户端语言返回编译生成后的页面
  - 通过差量直接修改确定位置的文本内容，也可以针对部分组件做特定语言的定制调整
  - 实现方案
    - 开发中，在前端页面提供国际化文本翻译支持，一键切换：容易遗漏，坐标位置变化会比较频繁
    - 以主语言为 `key`，建立与其他语言的翻译对应关系
    - 以模块为组织单元管理国际化内容
    - 需支持变量的注入
    - 提供 IDEA、VSCode 插件，用于原地进行国际化，并生成和管理国际化配置文件
- 客户端的操作请求均采用 Websocket 异步机制，
  服务端处理完毕后再以消息形式发回给客户端，从而避免出现超时响应，长时间暂用连接的问题
- 无状态服务，不能在服务内共享变量，如有需要，采用独立的缓存服务提供支持

## 应用 DSL 化

DSL（Domain-Specific Language，领域模型语言）作为表征层，
用于声明应用的数据结构和要做哪些事情，从最上层的视角来描述应用的整体，
以及应用的各个部分之间的关系。

实现层可采用多种方式，只要能以最优的方式实现应用所要做的事情即可。
并且，实现层可以在任何时候替换不适宜的技术实现，
而此类替换不会造成应用整体的变化，其依然为 DSL 所表述的形式。

也就是，DSL 是处于最上层且变化最小的层面，
通过 DSL 自上而下地描述一个系统，可以避免陷入到实现细节中，
从更高的视角来观察和分析系统的各个部分，并可以游刃有余地实施优化，
从而在保证系统稳定性的前提下，自由地改进和完善整个系统。

实现层可以视为是 DSL 的解释器或者执行虚拟机，其以 DSL 作为输入，
再按照 DSL 的描述获得对应的输出，其内部的执行方式与 DSL 是无关的，
实现层可以按照自己的方式对 DSL 进行解释并执行对应的逻辑，
从而将**描述（Presentation）与实现（Implementation）分离**。

> DSL 描述的是业务数据的结构和数据之间的关系，以及数据状态变化的驱动过程。
> **注**：驱动是在满足特定的条件时，自动从当前状态迁移到下一个状态，
> 而对其的描述仅包括状态和状态迁移的条件。

<!-- https://plantuml.com/deployment-diagram -->

```plantuml
frame customers as "消费层" {
  actor customer as "消费者（人或其他应用）"
}

frame implementation as "实现层" {
  entity dsl_xservice_vm as "XService 执行器"
  entity dsl_xapp_vm as "XApp 执行器"
  entity dsl_xweb_vm as "XWeb 执行器"
  entity dsl_other_vm as "Xxx 执行器"
}

frame presentation as "描述层" {
  collections dsl_xservice as "~*.xservice"
  collections dsl_xapp as "~*.xapp"
  collections dsl_xweb as "~*.xweb"
  collections dsl_other as "~*.xxx"
}

customer -down-> dsl_xservice_vm: 接口调用
customer -down-> dsl_xapp_vm: 接口调用
customer -down-> dsl_xweb_vm: 接口调用
customer -down-> dsl_other_vm: 接口调用

dsl_xservice_vm -down(0)-> dsl_xservice: 解析
dsl_xapp_vm -down(0)-> dsl_xapp: 解析
dsl_xweb_vm -down(0)-> dsl_xweb: 解析
dsl_other_vm -down(0)-> dsl_other: 解析
```

因此，渡舟平台所要做的就是：

- 定义描述层 DSL，维护应用的 DSL 树/森林
- 构建打包实现层代码，按 DSL 的类型拆分为多个可执行模块
- 调度可执行模块解析 DSL 并获得相应的输出
