---
title: 实现
description: 了解服务网关的技术实现
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

## API 网关 {#api}

## Web 资源网关 {#web}

### 根据 URL 请求生成站点入口页面 {#web-gen-site-html-via-url}

- 根据请求 URL 获取对应的 Site 数据
- 调用 xlib 函数生成站点页面，并返回给 Web 端

### 自定义静态资源根目录 {#web-custom-static-resources-path}

其实现要求：

- 支持指定绝对路径的系统文件目录或 classpath 中的资源目录作为静态资源的根目录
- 对静态资源的路由需放在过滤链的尾部，以便于在其之前处理站点的入口页面请求，
  并在请求资源（含静态资源）不存在时返回默认站点
- 可启/禁对静态资源的压缩
- 尽可能利用现有框架的处理实现，非必要，勿自行实现对静态资源的处理逻辑，
  避免编写输出文件流、资源缓存、资源压缩、资源
  [MIME 类型](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types)
  判定等代码

由于不同框架（Spring、Quarkus）的应用服务启动器的实现方式不一样，这里以
Quarkus 为例说明对静态资源自定义目录的支持方式。

Quarkus 自身支持自定义静态资源的根目录（详见
[From a local directory](https://quarkus.io/guides/http-reference#from-a-local-directory)），
其以监听 `StartupEvent` 的方式，在启动时，向 `Router` 添加静态资源处理器 `StaticHandler`：

```java {9,24,28,40} title="QuarkusStaticResources.java"
public class QuarkusStaticResources {
  private Handler<RoutingContext> handler;

  public void route(
    @Observes StartupEvent event,
    HttpBuildTimeConfig httpBuildTimeConfig,
    Router router
  ) {
    router.route().handler(context -> {
      getHandler(httpBuildTimeConfig).handle(context);
    });
  }

  public Handler<RoutingContext> getHandler(
    HttpBuildTimeConfig httpBuildTimeConfig
  ) {
    if (this.handler == null) {
      String path = GatewayConfigs.WEB_STATIC_RESOURCES_PATH.get();
      String ns = ResourceHelper.getPathNamespace(path);
      String root = ResourceHelper.removeNamespace(path, ns);

      if (ResourceConstants.FILE_NS.equals(ns)) {
        this.handler = StaticHandler.create(
          FileSystemAccess.ROOT, root
        );
      } else if (ResourceConstants.CLASSPATH_NS.equals(ns)) {
        this.handler = StaticHandler.create(
          FileSystemAccess.RELATIVE, root
        );
      }

      if (httpBuildTimeConfig.enableCompression) {
        Set<String> compressedMediaTypes
          = new HashSet<>(
            httpBuildTimeConfig
              .compressMediaTypes
              .orElse(new ArrayList<>())
          );

        this.handler = new HttpCompressionHandler(
          this.handler, compressedMediaTypes
        );
      }
    }

    return this.handler;
  }
}
```

> `QuarkusStaticResources` 只能放在标注了 `@QuarkusMain` 的模块中，
> 否则，其将不能被 Quarkus 扫描并加载。

由于 Nop `IHttpServerFilter` 的实现类是以高优先级注册到 Quarkus
的过滤器链中的（见 `HttpServerFilterRegistrar`），其优先级高于
`Router` 的处理器，因此，对静态资源的处理会在过滤链的最靠后的位置。
故而，在 `QuarkusStaticResources#route` 中只需要处理静态资源已存在的情况。

`QuarkusStaticResources#route` 会在应用服务启动时执行，此时，配置数据
`GatewayConfigs.WEB_STATIC_RESOURCES_PATH` 还未载入，
所以，需要延迟到首次请求处理时再创建 `Router` 的处理器实例。

Quarkus 的静态资源处理器 `StaticHandler` 已提供了对
`FileSystemAccess.ROOT` 和 `FileSystemAccess.RELATIVE`
两种静态资源目录的支持，前者用于指定系统文件的绝对路径，
后者则指定应用服务进程运行目录下的相对路径或者其 classpath 中的资源路径。
因此，只需要根据配置路径中的前缀是 `file:`，还是 `classpath:`
来确定采用何种资源目录形式。

Quarkus 的 `http` 配置对象 `HttpBuildTimeConfig` 可以直接写在接口参数中，
Quarkus 将自动注入真实的配置数据到该接口中，因此，通过 `httpBuildTimeConfig`
便可以获取是否已启用压缩等配置信息。

在启用了压缩的情况下，还需要自行通过 `HttpCompressionHandler` 包装
`StaticHandler` 才能真正启用对静态资源的压缩支持。其本质是移除值为
`HttpHeaders.IDENTITY` 的响应头 `HttpHeaders.CONTENT_ENCODING`，
从而由 Quarkus 自主对响应数据进行压缩。

> `Content-Encoding: identity` 是默认设置的响应头，用于禁用对响应数据的压缩。

## 参考 {#refs}

- [Nop 定制开发](/docs/platform/nop/custom)
