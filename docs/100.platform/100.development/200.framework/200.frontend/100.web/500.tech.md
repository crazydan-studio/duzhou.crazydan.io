---
title: 实现
description: 了解 Web 端的技术实现
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

## Vite 配置模块别名

```js {10} title="vite.config.js"
import path from 'path';
import { defineConfig } from 'vite';

export default defineConfig(() => {
  return {
    // ...
    resolve: {
      // https://stackoverflow.com/questions/66043612/vue3-vite-project-alias-src-to-not-working#answer-70251354
      alias: {
        '@/': path.join(__dirname, 'src/')
      }
    },
  };
});
```

## Vite 内联图片

```js {13,15} title="vite.config.js"
import { defineConfig } from 'vite';

export default defineConfig(() => {
  return {
    // ...
    css: {
      postcss: {
        plugins: [
          // https://github.com/bezoerb/postcss-image-inliner
          imageInliner({
            maxFileSize: 1024,
            // svg 以 Base64 编码内联
            b64Svg: true,
            // 配置正则表达式，以匹配需要内联的 css 属性
            filter: /^(background(?:-image)?)|(content)/
          })
        ]
      }
    },
  };
});
```

## 独立构建打包页面渲染器（`renderer`）

下面以使用 AMIS 作为渲染引擎的页面渲染器 `amis` 为例进行说明。

首先，在构建的入口脚本 `/src/amis/index.js`
中定义并调用页面渲染器函数 `render`：

```js title="/src/amis/index.js"
import 'amis/sdk/sdk';
// Note：当前项目不是 React 项目，只能以 SDK 方式使用 AMIS
// https://baidu.github.io/amis/zh-CN/docs/start/getting-started
const amis = amisRequire('amis/embed');

const conf = window.__APP_SITE_CONFIG__;
render(conf);

function render(conf) {
  amis.embed(/* ... */);
}
```

由于，在渡舟平台中，`Site` 的入口 HTML 将由 Java 后端服务动态生成，
而在运行环境中没有对 js 的构建支持，并且只有高版本的浏览器才支持原生的模块导入，
因此，为了支持更多的浏览器，只能采用 `<script/>` 标签载入页面渲染函数。

但，若要使用该函数，则需要将其定义为全局函数后再调用，
或者，在入口脚本中直接调用该函数，但其配置数据从指定的全局变量中获取。
为了降低对入口 HTML 的维护难度，简化其结构，渡舟平台采用了第二种方案，
也就是，将逻辑代码尽可能多地移到 js 脚本中，入口 HTML
仅负责 `Site`显示 页载入和渲染所必须的最少处理（即，显示开屏显示动画载入入口脚本）即可。

以下便为在运行环境中所生成的入口 HTML 的主要内容：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- title 和 logo 等配置 -->

    <style>/* 开屏动画样式 */</style>
  </head>
  <body>
    <div id="app"></div>

    <script>
      window.__APP_SITE_CONFIG__ = {
        el: '#app',
        // 动态填充的 Site 数据
      };
    </script>
    <script src="/js/renderer-amis-0.1.0.js"></script>
  </body>
</html>
```

该内容与开发页面渲染函数所使用的测试页面 `/index.html` 的内容是基本一致的，
主要差异就是 `window.__APP_SITE_CONFIG__` 使用的是测试数据，并且，
引入的页面渲染函数脚本为源码路径
`<script type="module" src="/src/amis/index.js"></script>`。

剩下的则只需要在 `vite.config.js` 中指定要构建的页面渲染函数入口脚本名称和路径，
并将其依赖的渲染引擎单独打包即可：

```js {16-17,45} title="vite.config.js"
import { defineConfig } from 'vite';

import pkg from './package.json';
import amisPkg from './node_modules/amis/package.json';

export default defineConfig(() => {
  return {
    // ...
    build: {
      // 增加构建产物的兼容范围
      target: 'es2015',
      rollupOptions: {
        // 摇树优化，将未使用的导出函数移除
        treeshake: true,
        input: {
          [`renderer-amis-${pkg.version}`]:
            path.join(__dirname, 'src/amis/index.js')
        },
        output: {
          // 入口脚本的位置
          entryFileNames: 'js/[name].js',
          // 各个依赖模块独立打包，并放在 js/lib 目录下
          chunkFileNames: 'js/lib/[name].js',
          manualChunks(id) {
            function include_any(libs) {
              for (let lib of libs) {
                if (id.includes(
                      '/node_modules/' + lib + '/'
                    )) {
                  return true;
                }
              }
              return false;
            }

            if (
              include_any([
                'amis',
                'amis-ui',
                'amis-formula',
                'amis-core',
                'video-react'
              ])
            ) {
              return `${amisPkg.name}-${amisPkg.version}`;
            }
          }
        }
      }
    },
  };
});
```

- `entryFileNames: 'js/[name].js'` 配置的是入口脚本的构建产物名称，
  而入口脚本则是在 `rollupOptions.input` 中指定的，`input`
  的键名即为 `[name]`，并且该键名可以是文件路径形式，
  以将脚本打包到 `dist/js/` 的子目录下
- `chunkFileNames: 'js/lib/[name].js'` 用于配置模块的构建产物名称，
  而要生成哪些模块，则通过 `rollupOptions.output.manualChunks`
  函数指定，该函数接受以模块路径为 `id` 的值，在根据该 `id`
  返回模块名称，若不同 `id` 返回的是相同的名称，则其将被打包到一个文件中，
  所以，可以将 AMIS 等引擎相关的组件打包在一起。
  模块名称将替换 `chunkFileNames` 中的 `[name]`，
  同时，其名称也可以是文件路径，并最终打包到 `dist/js/lib/` 的子目录下

## 显示开屏载入动画

> 本例需安装依赖：`npm i -D postcss-image-inliner`

开屏动画必须以最快速度显示动画，并在页面就绪后即刻隐藏，
并且，页面渲染的中间过程需在开屏动画之下的层中进行，
不能突然在最顶层出现页面的渲染片段。

因此，在入口 HTML 中需要：

- 内联且仅内联开屏动画的样式和图片，避免外联方式产生多次网络请求
- 在 `body` 的最顶层全屏显示载入动画，其他层的元素全部隐藏
- 在页面渲染完成后，通过附加 class 类名的方式结束动画，
  以方便灵活控制载入动画的显示和隐藏
- 载入动画与渲染页面的切换过程需要渐进过渡

最终，编写的入口 HTML 页面 `index.html` 的代码如下：

```html {16,19,36,42,46,50,55} title="index.html"
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        min-width: 0;
        min-height: 0;
        width: 100%;
        height: 100%;
        --Spinner-bg: url(/public/loading.svg);
      }

      .loading::after {
        z-index: 10000;
        opacity: 1;
        transition: opacity 0.5s ease-out;
        transition-delay: 0.2s;

        /* 禁用鼠标事件 */
        pointer-events: none;

        /* 配置开屏动画 */
        overflow: hidden;
        position: absolute;
        top: 0;
        width: 100%;
        height: 100%;

        content: '';
        background-image: var(--Spinner-bg);
        background-color: white; /* 遮挡底部元素 */
        background-position: center;
        background-size: 12rem;
        background-repeat: no-repeat;
      }
      .loading.done::after {
        opacity: 0;
      }

      .loading > * {
        opacity: 0;
        transition: opacity 0.5s ease-in;
      }
      .loading.done > * {
        opacity: 1;
      }
    </style>
  </head>
  <body class="loading">
    <div id="app"></div>

    <script>
      window.__APP_SITE_CONFIG__ = { /* ... */ };
    </script>
    <script src="/js/renderer-amis-0.1.0.js"></script>
  </body>
</html>
```

- 内联样式放在 `<head/>` 的最开始位置，其余外联 css、js 等均放在
  `<body/>` 中，避免等待外联资源的载入而出现白屏
- `--Spinner-bg: url(/public/loading.svg);`：
  `--Spinner-bg` 为 AMIS 的载入动画变量，这里将其覆盖为自定义的动画。
  并且，动画图片放在 `/public/` 下以便于 `postcss-image-inliner`
  插件将其以 Base64 编码内联到该 HTML 中
- 通过伪元素 `::after` 在目标节点上动态添加载入动画层，
  从而避免以手动或 js 脚本方式增减 dom 元素，提高其灵活性和适用范围
- 由于需要保证载入层显隐的渐进平滑性，这里采用透明度 `opacity`
  动画方式实现渐进显隐
- 在结束载入动画时，只需要在目标 dom 元素上添加 `done`
  类名（`$dom.classList.add('done')`）即可，若要重新启用载入动画，
  则移除 `done`（`$dom.classList.remove('done')`）就行了，
  操作十分便捷

**注**：`postcss-image-inliner` 插件内联以上载入动画的配置如下：

```js {11,13} title="vite.config.js"
import { defineConfig } from 'vite';
import imageInliner from 'postcss-image-inliner';

export default defineConfig(() => {
  return {
    // ...
    css: {
      postcss: {
        plugins: [
          imageInliner({
            // svg 以 Base64 编码内联
            b64Svg: true,
            // 配置正则表达式，以匹配需要内联的 css 属性
            filter: /^(--Spinner-bg)/
          })
        ]
      }
    },
  };
});
```

## 以 AMIS SDK 方式编写自定义组件

```js {3-4,15,20,28,43} title="SiteComponent"
import 'amis/sdk/sdk';

const amisLib = amisRequire('amis');
const React = amisRequire('react');

/**
 * <pre>
 * { type: 'site',
 *   title: '用户登录',
 *   className: 'w-full h-full',
 *   body: { ... }
 * }
 * </pre>
 */
class SiteComponent extends React.Component {
  componentDidMount() {
    // do something after this component is ready
  }

  render() {
    this.updateTitle();

    return this.renderBody();
  }

  renderBody() {
    // https://github.com/baidu/amis/blob/master/packages/amis/src/renderers/Wrapper.tsx#L50
    const { className, body, disabled, render } = this.props;

    const $children = render('body', body, { disabled });

    // https://react.dev/reference/react/createElement
    return React.createElement('div', { className }, $children);
  }

  updateTitle() {
    const { title } = this.props;

    document.title = title;
  }
}

amisLib.Renderer({
  test: /(^|\/)site/
})(SiteComponent);
```

AMIS SDK 方式编写的组件需要通过 `amisLib#Renderer` 进行注册，
并最终通过正则表达式对 JSON 组件对象的 `type` 值进行匹配，
若匹配上，则调用组件的渲染函数（`#render`）渲染该组件及其子组件。

AMIS 组件采用 React 框架开发，所以，自定义组件需要继承
`React.Component`，并实现 `#render()` 渲染函数。

在渲染函数内，可以通过 `this.props` 获取到该组件的配置数据以及
AMIS 的组件渲染函数 `render`，
通过该函数可以得到渲染后的子组件（`$children = render('body', body, {})`），
然后将子组件嵌入到当前组件元素内（`React.createElement('div', {}, $children)`）。

除了渲染组件及其子组件以外，还可以重载
[React Component](https://react.dev/reference/react/Component)
的其他函数，以实现不同的需求，比如，在 `#componentDidMount()` 做组件就绪处理。

## Vite 多页面开发

> 本例需安装依赖：`npm i -D vite-plugin-virtual-html sass`

渡舟平台对 Web 端的多页面开发的需求如下：

- 支持访问不同的页面（一个页面对应为一个站点），可共用一个 HTML 模板，
  不同的数据通过页面配置注入
- 能够引入并编译 scss，以提升 css 的编写效率

Vite 默认仅支持一个入口 HTML，若要支持多个入口并提供构建支持，需要通过插件
[vite-plugin-virtual-html](https://github.com/windsonR/vite-plugin-virtual-html)
来实现：

```js {9,16-17,20-22} title="vite.config.js"
import { defineConfig } from 'vite';
import virtualHtml from 'vite-plugin-virtual-html';

export default defineConfig(() => {
  return {
    // ...
    plugins: [
      virtualHtml({
        indexPage: 'signin/',
        data: {
          site_title: '渡舟平台',
          site_logoImage: '/logo.svg',
          site_loadingImage: './public/loading.svg'
        },
        pages: {
          'signin/': {
            template: '/public/template.html',
            data: {
              site_subTitle: '用户登录',
              styles:
                '<style lang="scss">@import "/public/pages/signin/index.scss";</style>',
              scripts: '<script src="/pages/signin/config.js"></script>'
            }
          },
          'admin/': {
            template: '/public/template.html',
            data: {
              site_subTitle: '后台管理',
              styles:
                '<style lang="scss">@import "/public/pages/admin/index.scss";</style>',
              scripts: '<script src="/pages/admin/config.js"></script>'
            }
          }
        }
      })
    ],
  };
});
```

- `indexPage`：用于指定根站点（`http://localhost:8080/`）的页面，该值与
  `pages` 中的 key 值相同
- 在 `pages` 的 key 值为相对于根站点的页面访问路径，若以分隔符 `/` 结尾，
  则访问地址为目录形式（`http://localhost:8080/signin/`），
  若无分隔符，则需要添加 `.html` 后缀（`http://localhost:8080/signin.html`）
- `pages[*].template` 为 HTML 模板文件路径（相对于当前项目），
  在其中可以以 `<%- site_subTitle %>` 引入定义在全局 `data` 或页面 `data`
  上的变量。**注**：以上样例中的 `styles` 和 `scripts`
  也为待注入到模板文件中的字符串，在完成占位替换后，会继续交给 Vite 进行构建

需要注意的是，在 HTML 中的 scss 文件需要以
`<style lang="scss">@import "/path/to/index.scss";</style>`
方式引入，才能启用 Vite 对 scss 的编译支持。

## 参考

- [nop-chaos/nop-site/vite.config.ts](https://gitee.com/canonical-entropy/nop-chaos/blob/master/packages/nop-site/vite.config.ts)
