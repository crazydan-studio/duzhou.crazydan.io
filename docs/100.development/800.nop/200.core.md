---
title: 核心内容
description: 理解 NOP 平台以及可逆计算的核心内容
authors:
  - flytreleft
---

import Header from '../../\_header.md';

<Header />

## 差量 - Delta

- 应用开发不能只有增量，还必须有减量，增量和减量合称为 **差量**
- 通过差量可以支持 **相似可复用**，而不再是 **相同可复用**。
  可以充分利用相似性以最大限度地提高系统的可复用性，并保证支持对差异化的能力开发
- 可最大限度地降低系统熵增的速率，保证系统的不断演化
- 定制化代码相当于是一种针对基础产品的 Delta 修正
- 差量 Delta 应该是架构设计中的第一类(First Class)概念。
  这样它才可以被独立识别、管理、存放。
  定制化代码应该和基础产品代码在物理层面分离，单独进行版本管理
- 全量是差量的一个特例
- Delta 可以脱离基础产品，独立的对多个 Delta 进行合并运算，
  将多个 Delta 打包为一个整体
- Delta 必须包含逆元，这样才能实现对原系统的剪裁。
  Delta 应该是新增、修改、删除的混合体
- 系统需具备一个**稳定的定位坐标系**。
  dA 与 A 分离之后，存放到独立存在的 Delta 中，那么它必然保留了某种定位坐标，
  只有这样，当 Delta 与 X 结合的时候，才可以重新找到原始的结构 A，然后与 A 相结合
  - 坐标系是指能够唯一定位到各个模型具体属性的方式方法

## DSL

- 通过 DSL 提取并抽象应用功能模块
- 一个应用就是一片 DSL 森林
- 不同的层级有不同的 DSL，从上至下，DSL 的细节会越来越多
- DSL 与具体的代码实现无关，它描述的是 **要做什么**，而不关心该怎么做
- 相同的模型具有不同的形态和表现形式，可以通过 DSL 支持不同的表达方式
- 支持差量合并，以实现 DSL 复用和扩展

### XLang

- XDef 是 XLang 中的领域模型定义语法，用于定义模型结构，约束属性数据，
  作用类似于采用 XML 语法的 XSD 语言和采用 JSON 语法的 JSON Schema。
  XDef 与它们的区别在于，它强调两点：
  - schema 描述与领域描述本身是**同形**的，也就是说 **schema 的 Tree 结构与领域模型的 Tree 结构是一致的**
  - 所有的集合元素都通过 `xdef:key-attr` 定义有唯一属性，从而确保领域描述的每个节点都有稳定且唯一的 xpath 路径
- 对于每一个**集合元素**，XDef 需要**明确定义用于区分不同子元素的唯一属性**，借助这一属性，
  可以高效、稳定的实现领域结构的 diff 算法（类似于 vue 框架中虚拟 DOM 的 diff），
  因此使用 XDef 定义一个领域结构，同时也意味着定义了该领域结构的差量化结构，我们可以很容易的计算两个领域结构的差与和
- 内置 `x:extends` 和 `x:gen-extends` 语法结构，所有 DSL 自动具有**差量编程**和**元编程**的能力，
  可以自由调用所有 Xpl 标签库，无需额外设计继承、库等抽象机制
- XLang 中不同的 DSL 共享了同样的扩展机制，使得它们只需要关注最核心的领域模型结构即可，
  而 `x:gen-extends` 的全部作用可以被看作是编译期的一种代码生成技术（产生式编程），
  简单的说就是不断拼接、转换、输出字符串或者 XNode，无论内部执行过程多复杂，
  引入多少 XPL 标签库，最终实际送到 DSL 解析器里的只有符合 XDef 定义的 DSL 模型文本

## 结构

- 核心为 **树结构**，开发应用的过程，就是调整树结构的过程
- 一个应用就是一颗 **树**，其中的模型就是 **子树**

## 讨论

- unison 是算是一种实现技巧吧，根据 content 得到 hash，从而得到一种类似名称，
  但是又能指向结构的东西，本身与版本号类似，只是它基于结构本身，
  而不是名称来确定唯一性而已。当我们想消除思维中的含混性的时候，
  最简单的做法就是进入**相空间**描述，将结构在时间轴上的每个点都区分出来，
  但是这样会大大增加整体描述的复杂性
- 在现有的技术条件下 GraphQL 是一个很好的选择。
  本质上是**信息分布的改变**，原先信息由服务端完全确定，
  现在交互信息是服务端和客户端共同决定的，
  一部分信息（具体使用哪些字段）这些信息放到了客户端，
  也就是说要改变原有信息的组织方式，把 A 和 B 的某种协商作为交互的一部分
- 原则上说每个服务都不是直接对接的，而是经过某种环境对象交互来发生相互作用的。
  所以真正的作用是 `A + B + 环境`，环境本身可以提供柔性适配的功能，可以注入外部公共知识、公共规则等
- 如果要以演化的、松耦合的方式来看待外部世界，那意味着任何时候你看见的都不是对象的全部，
  你只知道你需要知道的信息，而你需要知道别的信息的时候可以看到，你也可以选择以旧的方式继续看待原有的信息
- delta 需要一个预定义的**坐标系**作为参照物，delta 只有在同一个坐标系下才能进行合并。
  如果我们认为 delta 是针对整个系统的，就会导致预定义的坐标系过于复杂
- 实际上需要将整个系统分解为多个 DSL，然后一个 delta 包中包含多个 DSL delta
